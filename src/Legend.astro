---
import { gatherStats, scaleValueToBucket } from "./countryDataHelpers.js";

interface Props {
    dataViews?: any[];
    defaultView?: string;
    countryDetails?: Record<string, any>;
    normalizedFields?: string[];
    legendLabels?: {
        [value: number]: {
            label?: string;
            description?: string;
        }
    };
    classes?: {
        container?: string;
        title?: string;
        items?: string;
        colorBox?: string;
        label?: string;
    };
}

const defaultClasses = {
    container: "bg-white dark:bg-stone-950 rounded-lg p-4 z-30",
    title: "text-sm text-center font-semibold text-stone-900 dark:text-white mb-2",
    items: "grid grid-cols-5 gap-2",
    colorBox: "w-6 h-6 rounded border border-stone-300 dark:border-stone-600",
    label: "text-xs text-stone-700 dark:text-stone-300"
};

const { dataViews = [], defaultView, countryDetails = {}, normalizedFields = [], legendLabels = {}, classes = {} } = Astro.props;
const mergedClasses = { ...defaultClasses, ...classes };


// Calculate legend data using the same logic as createNormalizedObject
function calculateLegendData(fieldName) {
    if (!countryDetails || Object.keys(countryDetails).length === 0) {
        return [];
    }

    // Create dataArr same as createNormalizedObject
    const dataArr = Object.entries(countryDetails).map(([isoCode, details]) => ({
        isoCode,
        ...details,
    }));

    // Get stats using the same function
    const stats = gatherStats(dataArr, [fieldName]);
    
    if (!stats[fieldName]) {
        return [];
    }

    const { min, max } = stats[fieldName];
    
    // Generate legend items for each normalized value (3-6)
    const legendItems = [];
    for (let normalizedValue = 3; normalizedValue <= 6; normalizedValue++) {
        // Find the raw value range that maps to this normalized value
        // Using reverse calculation of scaleValueToBucket
        const ratio1 = (normalizedValue - 3) / (6 - 3); // Convert to 0-1 range
        const ratio2 = (normalizedValue + 1 - 3) / (6 - 3);
        
        const rangeMin = min + ratio1 * (max - min);
        const rangeMax = normalizedValue === 6 ? max : min + ratio2 * (max - min);
        
        legendItems.push({
            value: normalizedValue,
            rangeMin: Math.round(rangeMin),
            rangeMax: Math.round(rangeMax)
        });
    }
    
    return legendItems;
}
---

<div id="map-legend" class={mergedClasses.container} style="display: none;" data-current-view="">
    <h3 id="legend-title" class={mergedClasses.title}>Legend</h3>
    <div id="legend-items" class={mergedClasses.items}></div>
</div>

<script define:vars={{ dataViews, defaultView, countryDetails, legendLabels }}>
    // Import helper functions (need to be available in browser)
    function gatherStats(dataArr, fields) {
        const stats = {};
        if(fields.length) {
            fields.forEach((field) => {
                let minVal = Infinity;
                let maxVal = -Infinity;
                dataArr.forEach((item) => {
                    const val = Number(item[field]);
                    if (val < minVal) minVal = val;
                    if (val > maxVal) maxVal = val;
                });
                stats[field] = { min: minVal, max: maxVal };
            });
        }
        return stats;
    }

    function updateLegend() {
        const legend = document.getElementById('map-legend');
        const legendTitle = document.getElementById('legend-title');
        const legendItems = document.getElementById('legend-items');
        
        if (!legend || !legendTitle || !legendItems) return;
        
        // Get current view
        const svg = document.getElementById('worldmap');
        const currentViewId = svg?.getAttribute('data-current-view');
        
        if (!currentViewId || dataViews.length === 0) {
            legend.style.display = 'none';
            return;
        }
        
        const currentView = dataViews.find(v => v.id === currentViewId);
        if (!currentView) {
            legend.style.display = 'none';
            return;
        }
        
        // Update title and data attribute
        legendTitle.textContent = currentView.label || 'Legend';
        legend.setAttribute('data-current-view', currentViewId);
        
        // Clear existing items
        legendItems.innerHTML = '';
        
        // Get the primary field for the current view
        const primaryField = currentView.fields?.primary;
        if (!primaryField) {
            legend.style.display = 'none';
            return;
        }
        
        // Calculate legend data using same logic as createNormalizedObject
        const dataArr = Object.entries(countryDetails).map(([isoCode, details]) => ({
            isoCode,
            ...details,
        }));

        const stats = gatherStats(dataArr, [primaryField]);
        
        if (!stats[primaryField]) {
            legend.style.display = 'none';
            return;
        }

        const { min, max } = stats[primaryField];
        
        // First, calculate which normalized values actually exist in the data
        const normalizedValues = new Set();
        dataArr.forEach((item) => {
            const rawValue = Number(item[primaryField]);
            if (!isNaN(rawValue)) {
                let normalizedValue;
                // Use preset groups for access_rank (1-5)
                if (primaryField === 'access_rank') {
                    if (rawValue >= 1 && rawValue <= 15) normalizedValue = 1;
                    else if (rawValue >= 16 && rawValue <= 33) normalizedValue = 2;
                    else if (rawValue >= 34 && rawValue <= 50) normalizedValue = 3;
                    else if (rawValue >= 51 && rawValue <= 55) normalizedValue = 4;
                    else if (rawValue >= 56 && rawValue <= 88) normalizedValue = 5;
                }
                // Use preset groups for needs_rank (1-10)
                else if (primaryField === 'needs_rank') {
                    if (rawValue >= 1 && rawValue <= 4) normalizedValue = 1;
                    else if (rawValue >= 5 && rawValue <= 6) normalizedValue = 2;
                    else if (rawValue >= 7 && rawValue <= 9) normalizedValue = 3;
                    else if (rawValue >= 10 && rawValue <= 19) normalizedValue = 4;
                    else if (rawValue >= 20 && rawValue <= 28) normalizedValue = 5;
                    else if (rawValue >= 29 && rawValue <= 32) normalizedValue = 6;
                    else if (rawValue >= 33 && rawValue <= 38) normalizedValue = 7;
                    else if (rawValue >= 39 && rawValue <= 45) normalizedValue = 8;
                    else if (rawValue >= 46 && rawValue <= 59) normalizedValue = 9;
                    else if (rawValue >= 60 && rawValue <= 76) normalizedValue = 10;
                } else {
                    // Use the same scaleValueToBucket logic for other fields (scale 3-6)
                    if (min === max) {
                        normalizedValue = Math.round((3 + 6) / 2); // midpoint
                    } else if (rawValue <= min) {
                        normalizedValue = 3;
                    } else if (rawValue >= max) {
                        normalizedValue = 6;
                    } else {
                        const ratio = (rawValue - min) / (max - min);
                        const scaled = 3 + ratio * (6 - 3);
                        normalizedValue = Math.round(scaled);
                    }
                }
                if (normalizedValue !== undefined) {
                    normalizedValues.add(normalizedValue);
                }
            }
        });
        
        // Sort the normalized values
        const sortedValues = Array.from(normalizedValues).sort((a, b) => a - b);
        
        // Get titles from the current view if available
        const titles = currentView.fields?.titles || [];
        
        // Generate legend items only for values that exist
        sortedValues.forEach((normalizedValue, index) => {
            let rangeMin, rangeMax;

            // Use preset ranges for access_rank
            if (primaryField === 'access_rank') {
                if (normalizedValue === 1) { rangeMin = 1; rangeMax = 15; }
                else if (normalizedValue === 2) { rangeMin = 16; rangeMax = 33; }
                else if (normalizedValue === 3) { rangeMin = 34; rangeMax = 50; }
                else if (normalizedValue === 4) { rangeMin = 51; rangeMax = 55; }
                else if (normalizedValue === 5) { rangeMin = 56; rangeMax = 88; }
            }
            // Use preset ranges for needs_rank
            else if (primaryField === 'needs_rank') {
                if (normalizedValue === 1) { rangeMin = 1; rangeMax = 4; }
                else if (normalizedValue === 2) { rangeMin = 5; rangeMax = 6; }
                else if (normalizedValue === 3) { rangeMin = 7; rangeMax = 9; }
                else if (normalizedValue === 4) { rangeMin = 10; rangeMax = 19; }
                else if (normalizedValue === 5) { rangeMin = 20; rangeMax = 28; }
                else if (normalizedValue === 6) { rangeMin = 29; rangeMax = 32; }
                else if (normalizedValue === 7) { rangeMin = 33; rangeMax = 38; }
                else if (normalizedValue === 8) { rangeMin = 39; rangeMax = 45; }
                else if (normalizedValue === 9) { rangeMin = 46; rangeMax = 59; }
                else if (normalizedValue === 10) { rangeMin = 60; rangeMax = 76; }
            } else {
                // Use reverse calculation of scaleValueToBucket logic for other fields
                const ratio1 = (normalizedValue - 0.5 - 3) / (6 - 3);
                const ratio2 = (normalizedValue + 0.5 - 3) / (6 - 3);

                if (min === max) {
                    rangeMin = min;
                    rangeMax = max;
                } else {
                    rangeMin = normalizedValue === 3 ? min : min + ratio1 * (max - min);
                    rangeMax = normalizedValue === 6 ? max : min + ratio2 * (max - min);
                }
            }
            
            const itemDiv = document.createElement('div');
            itemDiv.className = 'flex items-center bg-stone-100 dark:bg-stone-900 rounded-sm';
            
            const colorBox = document.createElement('div');
            colorBox.className = 'w-8 h-full mr-4 rounded';
            colorBox.setAttribute('data-value', normalizedValue);
            
            
            // Create label container
            const labelContainer = document.createElement('div');
            labelContainer.className = 'flex flex-col';
            
            // Check if custom label/description exists
            const customLabels = legendLabels[normalizedValue];
            
            if (customLabels && customLabels.label) {
                // Use custom label
                const label = document.createElement('span');
                label.className = 'text-xs font-medium text-stone-700 dark:text-stone-300';
                label.textContent = customLabels.label;
                labelContainer.appendChild(label);
                
                // Add description if provided
                if (customLabels.description) {
                    const description = document.createElement('span');
                    description.className = 'text-xs text-stone-500 dark:text-stone-400';
                    description.textContent = customLabels.description;
                    labelContainer.appendChild(description);
                }
            } else if (titles && titles[index]) {
                // Use title from view configuration
                const titleLabel = document.createElement('span');
                titleLabel.className = 'text-xs font-medium text-stone-700 dark:text-stone-300';
                titleLabel.textContent = titles[index];
                labelContainer.appendChild(titleLabel);
                
                // Add range as secondary text
                const rangeLabel = document.createElement('span');
                rangeLabel.className = 'text-[10px] text-stone-500 dark:text-stone-400';
                if (min === max) {
                    rangeLabel.textContent = `${Math.round(min)}`;
                } else {
                    rangeLabel.textContent = `${Math.round(rangeMin)} - ${Math.round(rangeMax)}`;
                }
                labelContainer.appendChild(rangeLabel);
            } else {
                // Use default range display
                const label = document.createElement('span');
                label.className = 'text-xs text-stone-700 dark:text-stone-300';
                
                // Format the range display
                if (min === max) {
                    label.textContent = `${Math.round(min)}`;
                } else {
                    label.textContent = `${Math.round(rangeMin)} - ${Math.round(rangeMax)}`;
                }
                labelContainer.appendChild(label);
            }
            
            itemDiv.appendChild(colorBox);
            itemDiv.appendChild(labelContainer);
            legendItems.appendChild(itemDiv);
        });
        
        legend.style.display = 'block';
    }
    
    // Function to initialize legend and set up event listeners
    function initializeLegend() {
        updateLegend();

        // Listen for tab changes
        const tabs = document.querySelectorAll('[data-view-id]');
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                setTimeout(updateLegend, 100); // Small delay to ensure view is updated
            });
        });
    }

    // Update legend on both DOMContentLoaded and astro:page-load events
    document.addEventListener('DOMContentLoaded', initializeLegend);
    document.addEventListener('astro:page-load', initializeLegend);

    // Also update on astro:after-swap for compatibility
    document.addEventListener('astro:after-swap', () => {
        updateLegend();
    });
</script>