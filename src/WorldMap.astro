---
import { countryPaths } from "./countryPaths.js";
import { defaultCountryNames } from "./countryNames.js";
import { createNormalizedObject } from "./countryDataHelpers.js";
import CirclePoints from "./CountryRankCircles/CirclePoints.astro";
import SearchButton from "./SearchButton.astro";
import Modal from "./Modal.astro";
import Legend from "./Legend.astro";

interface DataView {
    /** Unique identifier for the data view */
    id: string;
    /** Human-readable label for the view */
    label: string;
    /** Field configuration for data mapping */
    fields: {
        /** Primary data field name for choropleth coloring */
        primary?: string;
        /** Secondary data field name for additional visualization */
        secondary?: string;
    };
    /** CSS class configuration for styling */
    classes?: {
        /** CSS class for primary data visualization */
        primary?: string;
        /** CSS class for secondary data visualization */
        secondary?: string;
        /** CSS class for circle elements */
        circle?: string;
    };
}

interface CountryData {
    [fieldName: string]: string | number | null | undefined;
}

interface NormalizedCountryData extends CountryData {
    /** Original ISO country code */
    isoCode: string;
}

interface LegendLabels {
    [value: number]: {
        label?: string;
        description?: string;
    };
}

interface Props {
    /** CSS class overrides for component styling */
    classes?: {
        /** Map controls container classes */
        mapControls?: string;
        /** Zoom button classes */
        zoomButton?: string;
        /** Data view tabs container classes */
        tabs?: string;
        /** Individual tab classes */
        tab?: string;
        /** Active tab classes */
        activeTab?: string;
        /** Main SVG map classes */
        worldMap?: string;
        /** Tooltip classes */
        tooltip?: string;
        /** Modal-related classes */
        modal?: {
            overlay?: string;
            modal?: string;
            closeBtn?: string;
            content?: string;
        };
        /** Search functionality classes */
        search?: {
            searchButton?: string;
            searchContainer?: string;
            searchInput?: string;
            searchResults?: string;
            searchResultItem?: string;
        };
    };
    /** URL path template for country links (e.g., '/country/') */
    linkPath?: string;
    /** Custom country name overrides mapping ISO codes to display names */
    countryNames?: Record<string, string>;
    /** Interaction mode - 'link' for navigation, 'modal' for popup details */
    mode?: "link" | "modal";
    /** Raw country data indexed by ISO code */
    countryDetails?: Record<string, CountryData>;
    /** Field names that should be normalized for visualization */
    normalizedFields?: string[];
    /** Configuration for different data visualization views */
    dataViews?: DataView[];
    /** ID of the default view to display on load */
    defaultView?: string;
    /** Custom labels for legend values */
    legendLabels?: LegendLabels;
}

const defaultClasses = {
    mapControls: "z-30 absolute top-4 left-4 flex flex-col",
    zoomButton: "text-white text-2xl bg-stone-900 dark:bg-stone-950 rounded-lg w-8 h-8 mt-2",
    tabs: "z-30 absolute top-4 right-4 flex bg-stone-900 dark:bg-stone-950 rounded-lg p-1",
    tab: "px-3 py-2 text-sm text-white cursor-pointer rounded transition-colors hover:bg-stone-700",
    activeTab: "bg-stone-700 text-white",
    worldMap: "w-full h-[75vh] z-0 relative dark:bg-stone-900",
    tooltip: "absolute hidden bg-stone-800 text-white px-2 rounded-md pointer-events-none",
    modal: {
        overlay: "fixed inset-0 bg-black bg-opacity-50 z-50 transition-opacity duration-300",
        modal: "fixed top-[82px] right-0 h-screen bg-white dark:bg-stone-800 shadow-2xl transform transition-transform duration-300 ease-in-out translate-x-full",
        closeBtn: "absolute top-4 right-4 text-2xl text-stone-600 dark:text-stone-300 cursor-pointer z-10",
        content: "p-6 pt-16 h-full overflow-y-auto",
    },
};

const {
    classes = {},
    linkPath = "",
    countryNames,
    mode = "link",
    countryDetails = {},
    normalizedFields = {},
    dataViews = [],
    defaultView,
} = Astro.props;

const mergedClasses = {
    ...defaultClasses,
    ...classes,
    modal: { ...defaultClasses.modal, ...classes.modal },
};
const mergedCountryNames = { ...defaultCountryNames, ...countryNames };

const normalizedDetails = createNormalizedObject(countryDetails, normalizedFields);
---
<div>
{
    dataViews.length > 0 && (
        <div id="data-tabs" class={mergedClasses.tabs}>
            {dataViews.map((view) => (
                <button
                    class={`${mergedClasses.tab} ${view.id === (defaultView || dataViews[0]?.id) ? mergedClasses.activeTab : ""}`}
                    data-view-id={view.id}
                >
                    {view.label}
                </button>
            ))}
        </div>
    )
}

<div id="map-controls" class={mergedClasses.mapControls} role="toolbar" aria-label="Map controls">
    <button id="zoom-in-button" title="Zoom In" aria-label="Zoom in on map" class={mergedClasses.zoomButton}>+</button>
    <button id="zoom-out-button" title="Zoom Out" aria-label="Zoom out on map" class={mergedClasses.zoomButton}>-</button>
    <button id="scroll-zoom-toggle" title="Toggle Scroll Zoom" aria-label="Toggle scroll zoom" class={mergedClasses.zoomButton}>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 125">
            <path d="M42.5 21.7c0-.8-.6-1.5-1.5-1.5-.8 0-1.5.6-1.5 1.4v3c0 .9.6 1.5 1.4 1.6.9 0 1.6-.7 1.6-1.5v-3ZM41 29.2c-.9 0-1.6.6-1.6 1.4v3c0 .9.6 1.5 1.4 1.5.9 0 1.5-.6 1.6-1.4v-3c0-.9-.7-1.6-1.5-1.6Zm-1.4-13.6c0 .8.7 1.5 1.5 1.5s1.5-.6 1.5-1.4V13h3.1l-4.3-7.8-4.6 7.6 2.9.1v2.7Zm1.2 49.6c-.8 0-1.5.6-1.4 1.5v3c0 .8.6 1.5 1.5 1.5.8 0 1.5-.7 1.5-1.6v-3c0-.8-.7-1.4-1.6-1.4Zm.1 9c-.8 0-1.5.6-1.5 1.5v3c0 .8.7 1.5 1.5 1.5.9 0 1.5-.7 1.5-1.6v-3c0-.8-.7-1.4-1.5-1.4Zm1.6 10.4c0-.8-.7-1.4-1.5-1.4-.9 0-1.5.7-1.5 1.5v1.7h-2.9l4.7 7.7 4.3-7.8h-3l-.1-1.6Z"/>
            <path d="M80.3 45.9c-2.4-2.6-4.7-3.2-7.6-1.9a5.3 5.3 0 0 0-2.6 2.4 6 6 0 0 0-6.3 1 5.9 5.9 0 0 0-2.6 3.5 5 5 0 0 0-4.7 1.5 6 6 0 0 0-1.8 2.4l-2.4-2.3a154 154 0 0 0-3.6-3.2v-.1a8 8 0 0 0-6.4-8v-1.5c0-.9-.6-1.5-1.5-1.6-.8 0-1.5.7-1.5 1.5v1.7c-3.6.7-6.3 4-6.3 8s2.8 7.1 6.4 7.9v3.5c0 .8.6 1.5 1.4 1.5.8 0 1.4-.6 1.5-1.3l.4.5.1.1 4 5c.2 2.2 0 4-.3 5.9-.6 4-1 7.7 3.7 11.2 9.4 7 16 10.7 22.1 10.7 4.8 0 9.2-2.3 14.4-7.2 17.1-16 4.7-29.4-6.3-41.3Zm4.4 39c-9.3 8.8-15 9.4-32.7-3.7-3.4-2.5-3-4.7-2.6-8.4.1-.8.3-1.7.3-2.7l7.1 8c.6.6 1.5.7 2.1.1.7-.5.7-1.5.1-2.1q-7.3-8.2-13.9-16.4v-.1a54.6 54.6 0 0 1-5.4-7.7c-1.6-2.2-1.4-3-.6-4 .5-.5 1-.7 1.6-.7.8 0 1.8.5 2.8 1.5l2.3 2.1a165.2 165.2 0 0 1 13.5 12.9 1.5 1.5 0 0 0 2.2-2l-3.6-3.9s-.6-.7-.5-1.4c0-.6.4-1.1 1-1.7.1 0 .2 0 .2-.2 1.5-1.6 3.3 0 3.7.2.6.5 1.4.5 2 0 .6-.5.6-1.4.1-2 0 0-.3-.5-.3-1.1.1-.6.6-1.2 1.4-1.8 2.4-1.8 4-.4 4.3.1.4.5 1.1.7 1.8.4.6-.2 1-.9.9-1.5 0-.2 0-1.4 1.4-2 1.3-.6 2.4-.9 4.2 1.1 11.5 12.4 21.4 23 6.6 37Z"/>
          </svg>
    </button>
    <SearchButton countryNames={mergedCountryNames} classes={classes.search} />
</div>

<svg
    id="worldmap"
    class={mergedClasses.worldMap}
    xmlns="http:
  viewBox="-400 -300 3400 1800"
    data-current-view={defaultView || dataViews[0]?.id}
    role="img"
    aria-label="Interactive world map with country data visualization"
    tabindex="0"
>
    {
        Object.entries(countryPaths).map(([isoCode, path]) => {
            const normalizedDetail = normalizedDetails[isoCode] || {};
            const countryDetail = countryDetails[isoCode] || {};
            const dataAttrString = Object.entries(normalizedDetail)
                .map(([key, value]) => `data-${key}="${String(value)}"`)
                .join(" ");

            // Generate choropleth classes based on normalized values
            let choroplethClasses = "";
            dataViews.forEach(view => {
                const primaryField = view.fields?.primary;
                if (primaryField && normalizedDetail[primaryField]) {
                    const value = normalizedDetail[primaryField];
                    choroplethClasses += ` choropleth-${view.id}-${value}`;
                }
            });

            return (
                <Fragment
                    set:html={`
          <a
            ${mode === "link" ? `href="${linkPath}${isoCode}"` : ""}
            data-iso="${isoCode}"
            title="${mergedCountryNames[isoCode]}"
            ${dataAttrString}
            class="country-path${choroplethClasses}"
            style="cursor: pointer;"
          >
            ${path}
          </a>
        `}
                />
            );
        })
    }
    {
        dataViews.map((view) => (
            <CirclePoints
                countryData={countryDetails}
                dataViews={[view]}
                activeView={view.id}
                style={view.id !== (defaultView || dataViews[0]?.id) ? "display: none;" : ""}
            />
        ))
    }
</svg>

<div id="tooltip" class={mergedClasses.tooltip}></div>

<Modal id="country-modal" classes={mergedClasses.modal}>
    <slot name="modal-content">
        <!-- Default content will be injected here by JavaScript -->
    </slot>
</Modal>

<Legend 
    dataViews={dataViews}
    defaultView={defaultView}
    countryDetails={countryDetails}
    normalizedFields={normalizedFields}
    legendLabels={Astro.props.legendLabels}
/>

<!-- Country Grid List -->
<div id="country-grid" class="mt-4 px-2" role="region" aria-label="Country data grid">
    <h3 id="country-grid-title" class="text-lg font-semibold mb-1 text-stone-800 dark:text-stone-200">Countries by Current View</h3>
    <div id="country-grid-container" 
         class="grid grid-cols-2 sm:grid-cols-4 md:grid-cols-5 lg:grid-cols-6 xl:grid-cols-8 gap-1 px-12 mb-8"
         role="grid"
         aria-labelledby="country-grid-title">
        <!-- Countries will be dynamically inserted here -->
    </div>
</div>
</div>

<style>
    /* Base country path styles */
    .country-path path {
        fill: #e5e7eb; /* gray-200 */
        stroke: #9ca3af; /* gray-400 */
        stroke-width: 0.5;
        transition: all 0.2s ease;
    }
    
    .country-path:hover path {
        fill: #d1d5db; /* gray-300 */
        stroke: #6b7280; /* gray-500 */
        stroke-width: 1;
    }
    
    /* Choropleth color scales for each view */
    /* Value 3 - Low (red) */
    svg[data-current-view="access"] .choropleth-access-3 path,
    svg[data-current-view="needs"] .choropleth-needs-3 path,
    svg[data-current-view="combined"] .choropleth-combined-3 path {
        fill: #f87171; /* red-400 */
    }
    
    /* Value 4 - Medium-Low (amber) */
    svg[data-current-view="access"] .choropleth-access-4 path,
    svg[data-current-view="needs"] .choropleth-needs-4 path,
    svg[data-current-view="combined"] .choropleth-combined-4 path {
        fill: #fbbf24; /* amber-400 */
    }
    
    /* Value 5 - Medium-High (emerald) */
    svg[data-current-view="access"] .choropleth-access-5 path,
    svg[data-current-view="needs"] .choropleth-needs-5 path,
    svg[data-current-view="combined"] .choropleth-combined-5 path {
        fill: #34d399; /* emerald-400 */
    }
    
    /* Value 6 - High (blue) */
    svg[data-current-view="access"] .choropleth-access-6 path,
    svg[data-current-view="needs"] .choropleth-needs-6 path,
    svg[data-current-view="combined"] .choropleth-combined-6 path {
        fill: #3b82f6; /* blue-500 */
    }
    
    /* Selected country override */
    .country-path path.selected {
        fill: #3b82f6 !important;
        stroke: #1e40af !important;
        stroke-width: 2 !important;
    }
    
    /* Grid item colors - default grey for countries with no data */
    .country-grid-item {
        background-color: #e5e7eb; /* gray-200 */
    }
    
    /* Prevent flash by hiding map until viewBox is calculated */
    #worldmap {
        visibility: hidden;
    }
    
    #worldmap.ready {
        visibility: visible;
    }
</style>

<script define:vars={{ mode, dataViews, defaultView, mergedCountryNames, countryDetails }}>
    // Color utility functions
    window.rgbToHex = function(rgb) {
        if (!rgb || !rgb.startsWith('rgb')) {
            return rgb;
        }
        
        const rgbMatch = rgb.match(/\d+/g);
        if (!rgbMatch || rgbMatch.length < 3) {
            return '#e5e7eb';
        }
        
        return '#' + rgbMatch.slice(0, 3).map(x => {
            const hex = parseInt(x).toString(16);
            return hex.length === 1 ? '0' + hex : hex;
        }).join('');
    };

    window.getCountryColor = function(isoCode, svg, useCache = true) {
        if (!svg || !isoCode) {
            return '#e5e7eb';
        }
        
        // Check cache first if enabled
        const currentView = svg.getAttribute('data-current-view');
        const cacheKey = `${isoCode}-${currentView}`;
        
        if (useCache && colorCache.has(cacheKey)) {
            return colorCache.get(cacheKey);
        }
        
        try {
            const countryPath = svg.querySelector(`[data-iso="${isoCode}"] path`);
            if (!countryPath) {
                const defaultColor = '#e5e7eb';
                if (useCache) colorCache.set(cacheKey, defaultColor);
                return defaultColor;
            }
            
            const computedStyle = window.getComputedStyle(countryPath);
            const fillColor = computedStyle.fill;
            
            const hexColor = window.rgbToHex(fillColor);
            const finalColor = hexColor && hexColor !== '#e5e7eb' ? hexColor : '#e5e7eb';
            
            // Cache the result with size management
            if (useCache) {
                // Clear oldest entries if cache is getting too large
                if (colorCache.size >= MAX_CACHE_SIZE) {
                    const firstKey = colorCache.keys().next().value;
                    colorCache.delete(firstKey);
                }
                colorCache.set(cacheKey, finalColor);
            }
            
            return finalColor;
            
        } catch (error) {
            console.warn(`Failed to get color for country ${isoCode}:`, error);
            const defaultColor = '#e5e7eb';
            if (useCache) colorCache.set(cacheKey, defaultColor);
            return defaultColor;
        }
    };

    document.addEventListener("DOMContentLoaded", initializeSvgInteractions);
    document.addEventListener("astro:page-load", initializeSvgInteractions);

    let originalSlotTemplate = null;
    
    // Performance optimization variables
    let gridUpdateTimeout = null;
    let colorCache = new Map();
    let lastGridHTML = '';
    let isGridUpdating = false;
    const MAX_CACHE_SIZE = 500; // Limit cache size to prevent memory leaks

    function captureSlotTemplate() {
        if (!originalSlotTemplate) {
            const slotContent = document.querySelector("#country-modal-body > div");
            if (
                slotContent &&
                slotContent.innerHTML.trim() &&
                !slotContent.innerHTML.includes("Default content will be injected")
            ) {
                originalSlotTemplate = slotContent.cloneNode(true);
            }
        }
    }

    function openCountryModal(isoCode) {
        const countryName = mergedCountryNames[isoCode] || "Unknown";
        const countryData = countryDetails[isoCode] || {};

        // Don't open modal if there's no data for this country
        if (!countryDetails[isoCode] || Object.keys(countryData).length === 0) {
            return;
        }

        captureSlotTemplate();

        let content;

        if (originalSlotTemplate) {
            const clonedContent = originalSlotTemplate.cloneNode(true);
            window.populateDataAttributes(clonedContent, isoCode, countryName, countryData);
            content = clonedContent.outerHTML;
        } else {
            content = `<h2 class="text-2xl font-bold mb-4 text-stone-900 dark:text-white">${countryName}</h2>
	      <div class="space-y-2">
	        <p class="text-stone-600 dark:text-stone-300"><span class="font-semibold">Country code:</span> ${isoCode}</p>
	        ${
                Object.keys(countryData).length > 0
                    ? Object.entries(countryData)
                          .map(
                              ([key, value]) =>
                                  `<p class="text-stone-600 dark:text-stone-300"><span class="font-semibold">${key}:</span> ${value}</p>`,
                          )
                          .join("")
                    : '<p class="text-stone-500 dark:text-stone-400 italic">No additional data available</p>'
            }
	      </div>`;
        }

        window.openModal("country-modal", content);
    }

    function initializeSvgInteractions() {
        const svg = document.getElementById("worldmap");
        if (!svg) {
            console.error("WorldMap SVG element not found - component may not function properly");
            return;
        }

        try {
            captureSlotTemplate();
        } catch (error) {
            console.warn("Failed to capture slot template:", error);
        }

        const tooltip = document.getElementById("tooltip");
        let isPanning = false;
        let startX = 0,
            startY = 0;
        let viewBox = { x: 0, y: 0, width: 800, height: 600 };
        let selectedCountry = null;
        let scrollZoomEnabled = false; // Disabled by default

        function setInitialViewBox() {
            const svgRect = svg.getBoundingClientRect();
            const contentWidth = 2528;
            const contentHeight = 1200;
            const contentAspectRatio = contentWidth / contentHeight;
            const containerAspectRatio = svgRect.width / svgRect.height;

            let viewBoxWidth, viewBoxHeight;
            if (containerAspectRatio > contentAspectRatio) {
                viewBoxHeight = contentHeight;
                viewBoxWidth = contentHeight * containerAspectRatio;
            } else {
                viewBoxWidth = contentWidth;
                viewBoxHeight = contentWidth / containerAspectRatio;
            }
            viewBox = {
                x: 83 - (viewBoxWidth - contentWidth) / 2,
                y: 45 - (viewBoxHeight - contentHeight) / 2,
                width: viewBoxWidth,
                height: viewBoxHeight,
            };
            svg.setAttribute("viewBox", `${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`);
            svg.classList.add("ready");
        }

        function showTooltip(event) {
            const target = event.target.closest("a, button");
            if (!target) return;
            const title = target.getAttribute("title");
            if (!title) return;
            const svgRect = svg.getBoundingClientRect();
            const mouseX = event.clientX - svgRect.left;
            const mouseY = event.clientY - svgRect.top;
            tooltip.style.left = `${mouseX + 10}px`;
            tooltip.style.top = `${mouseY + 10}px`;
            tooltip.innerText = title;
            tooltip.style.display = "block";
        }

        function hideTooltip() {
            tooltip.style.display = "none";
        }

        svg.addEventListener("mouseover", showTooltip);
        svg.addEventListener("mousemove", showTooltip);
        svg.addEventListener("mouseout", hideTooltip);

        svg.addEventListener("mousedown", (e) => {
            isPanning = true;
            startX = e.clientX;
            startY = e.clientY;
        });

        svg.addEventListener("mousemove", (e) => {
            if (isPanning) {
                viewBox.x += startX - e.clientX;
                viewBox.y += startY - e.clientY;
                svg.setAttribute("viewBox", `${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`);
                startX = e.clientX;
                startY = e.clientY;
            }
        });

        svg.addEventListener("mouseup", () => (isPanning = false));
        svg.addEventListener("mouseleave", () => (isPanning = false));

        svg.addEventListener("wheel", (e) => {
            if (scrollZoomEnabled) {
                e.preventDefault();
                const scaleFactor = 1 - e.deltaY * 0.002;
                zoom(scaleFactor, e.clientX, e.clientY);
            }
        });

        function zoom(scaleFactor, clientX, clientY) {
            try {
                const svgPoint = svg.createSVGPoint();
                const screenCTM = svg.getScreenCTM();
                
                if (!screenCTM) {
                    console.warn("Cannot get screen coordinate transformation matrix for zoom");
                    return;
                }
                
                const loc = Object.assign(svgPoint, { x: clientX, y: clientY }).matrixTransform(
                    screenCTM.inverse(),
                );
                const newWidth = viewBox.width * scaleFactor;
                const newHeight = viewBox.height * scaleFactor;

                if ((newWidth <= 5500 && newHeight <= 5500) || scaleFactor < 1) {
                    if (newWidth >= 100 && newHeight >= 100) {
                        viewBox.x = loc.x - (loc.x - viewBox.x) * scaleFactor;
                        viewBox.y = loc.y - (loc.y - viewBox.y) * scaleFactor;
                        viewBox.width = newWidth;
                        viewBox.height = newHeight;
                        svg.setAttribute("viewBox", `${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`);
                    }
                }
            } catch (error) {
                console.warn("Zoom operation failed:", error);
            }
        }

        document.getElementById("zoom-in-button").addEventListener("click", () => {
            zoom(0.8, svg.clientWidth / 2, svg.clientHeight / 2);
        });

        document.getElementById("zoom-out-button").addEventListener("click", () => {
            zoom(1.2, svg.clientWidth / 2, svg.clientHeight / 2);
        });

        // Scroll zoom toggle button
        const scrollZoomToggle = document.getElementById("scroll-zoom-toggle");
        if (scrollZoomToggle) {
            scrollZoomToggle.addEventListener("click", () => {
                scrollZoomEnabled = !scrollZoomEnabled;
                scrollZoomToggle.style.opacity = scrollZoomEnabled ? "1" : "0.5";
                scrollZoomToggle.title = scrollZoomEnabled ? "Disable Scroll Zoom" : "Enable Scroll Zoom";
                scrollZoomToggle.setAttribute("aria-label", scrollZoomEnabled ? "Disable scroll zoom" : "Enable scroll zoom");
            });
            // Set initial state (disabled)
            scrollZoomToggle.style.opacity = "0.5";
        }



        function initializeDataTabs() {
            const tabs = document.querySelectorAll("[data-view-id]");
            if (tabs.length === 0) return;

            tabs.forEach((tab) => {
                tab.addEventListener("click", () => {
                    const viewId = tab.getAttribute("data-view-id");
                    switchDataView(viewId);
                });
            });
        }

        function switchDataView(viewId) {
            const tabs = document.querySelectorAll("[data-view-id]");
            tabs.forEach((tab) => {
                const isActive = tab.getAttribute("data-view-id") === viewId;
                if (isActive) {
                    tab.classList.add("bg-stone-700", "text-white");
                } else {
                    tab.classList.remove("bg-stone-700", "text-white");
                }
            });

            const svg = document.getElementById("worldmap");
            if (svg) {
                svg.setAttribute("data-current-view", viewId);
                // Clear color cache when view changes to ensure fresh colors
                colorCache.clear();
            }

            const allViewGroups = document.querySelectorAll("[data-view-group]");
            allViewGroups.forEach((group) => {
                const groupViewId = group.getAttribute("data-view-group");
                if (groupViewId === viewId) {
                    group.style.display = "block";
                } else {
                    group.style.display = "none";
                }
            });

            // Update country grid with debouncing
            debouncedUpdateCountryGrid(viewId);
        }

        // Debounced version of updateCountryGrid for performance
        function debouncedUpdateCountryGrid(viewId) {
            if (gridUpdateTimeout) {
                clearTimeout(gridUpdateTimeout);
            }
            
            gridUpdateTimeout = setTimeout(() => {
                updateCountryGrid(viewId);
            }, 150); // 150ms debounce delay
        }

        function updateCountryGrid(viewId) {
            // Prevent concurrent updates
            if (isGridUpdating) {
                return;
            }
            isGridUpdating = true;
            
            const container = document.getElementById("country-grid-container");
            if (!container) {
                console.warn("Country grid container not found");
                isGridUpdating = false;
                return;
            }

            // Find the active view configuration
            const activeView = dataViews.find(view => view.id === viewId);
            if (!activeView) {
                console.warn(`Active view '${viewId}' not found in dataViews`);
                container.innerHTML = '<p class="text-stone-500 dark:text-stone-400 col-span-full">View configuration not found</p>';
                isGridUpdating = false;
                return;
            }

            // Get the primary field to sort by
            const primaryField = activeView.fields?.primary;
            if (!primaryField) {
                console.info(`No primary field defined for view '${viewId}'`);
                container.innerHTML = '<p class="text-stone-500 dark:text-stone-400 col-span-full">No data available for this view</p>';
                isGridUpdating = false;
                return;
            }

            // Create array of countries with their values
            const countriesWithValues = [];
            Object.entries(countryDetails).forEach(([isoCode, data]) => {
                if (data && data[primaryField] !== undefined && data[primaryField] !== null) {
                    countriesWithValues.push({
                        iso: isoCode,
                        name: mergedCountryNames[isoCode] || isoCode,
                        value: data[primaryField],
                        data: data
                    });
                }
            });

            // Sort by value (ascending - least to most)
            countriesWithValues.sort((a, b) => {
                // Convert to numbers for comparison
                const aNum = Number(a.value);
                const bNum = Number(b.value);
                
                // If both can be treated as numbers, compare numerically
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return aNum - bNum;
                }
                
                // Otherwise, fall back to string comparison
                return String(a.value).localeCompare(String(b.value));
            });

            // Use requestAnimationFrame for better performance with large datasets
            requestAnimationFrame(() => {
                generateGridHTML(countriesWithValues, container);
                isGridUpdating = false;
            });
        }
        
        function generateGridHTML(countriesWithValues, container) {
            // Batch process countries for better performance
            const BATCH_SIZE = 50;
            const totalCountries = countriesWithValues.length;
            
            if (totalCountries <= BATCH_SIZE) {
                // Small dataset - process immediately
                const html = renderCountries(countriesWithValues);
                container.innerHTML = html || '<p class="text-stone-500 dark:text-stone-400 col-span-full">No data available</p>';
                addGridEventListeners(container);
            } else {
                // Large dataset - use progressive rendering
                container.innerHTML = '<p class="text-stone-500 dark:text-stone-400 col-span-full">Loading countries...</p>';
                renderCountriesBatched(countriesWithValues, container, 0);
            }
        }
        
        function renderCountries(countries) {
            return countries.map(country => {
                const displayValue = typeof country.value === 'number' 
                    ? Math.round(country.value).toString() 
                    : country.value;
                
                // Get the color from the actual SVG element's computed style
                const svg = document.getElementById("worldmap");
                const bgColor = window.getCountryColor ? 
                    window.getCountryColor(country.iso, svg) : 
                    '#e5e7eb'; // Fallback if utility not loaded
                
                return `
                    <div class="country-grid-item px-2 py-1 rounded cursor-pointer transition-all hover:scale-105 flex justify-between items-center"
                         style="background-color: ${bgColor};"
                         data-iso="${country.iso}"
                         role="gridcell"
                         tabindex="0"
                         aria-label="${country.name}: ${displayValue}"
                         onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();this.click();}">
                        <div class="font-semibold text-sm text-stone-800 dark:text-stone-200 truncate" title="${country.name}">
                            ${country.name}
                        </div>
                        <div class="text-sm font-normal text-stone-700 dark:text-stone-300">
                            ${displayValue}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function renderCountriesBatched(countries, container, startIndex) {
            const BATCH_SIZE = 50;
            const endIndex = Math.min(startIndex + BATCH_SIZE, countries.length);
            const batch = countries.slice(startIndex, endIndex);
            
            if (startIndex === 0) {
                // First batch - replace content
                container.innerHTML = renderCountries(batch);
            } else {
                // Subsequent batches - append content
                container.insertAdjacentHTML('beforeend', renderCountries(batch));
            }
            
            // Continue with next batch if there are more countries
            if (endIndex < countries.length) {
                requestAnimationFrame(() => {
                    renderCountriesBatched(countries, container, endIndex);
                });
            } else {
                // All countries rendered - add event listeners
                addGridEventListeners(container);
            }
        }
        
        function addGridEventListeners(container) {
            // Add click handlers to grid items
            container.querySelectorAll('.country-grid-item').forEach(item => {
                item.addEventListener('click', () => {
                    const isoCode = item.getAttribute('data-iso');
                    selectCountry(isoCode, mode === 'modal');
                });
            });
        }

        initializeDataTabs();

        // Initialize country grid with default view
        const initialView = defaultView || (dataViews && dataViews.length > 0 ? dataViews[0].id : null);
        if (initialView) {
            updateCountryGrid(initialView);
        }

        document.addEventListener("countrySelected", (e) => {
            selectCountry(e.detail.isoCode);
        });

        function selectCountry(isoCode, forceModal = false) {
            const countryData = countryDetails[isoCode];
            const hasData = countryData && Object.keys(countryData).length > 0;
            
            // Don't select if in modal mode and country has no data
            if ((forceModal || mode === "modal") && !hasData) {
                return;
            }
            
            if (selectedCountry) {
                selectedCountry.classList.remove("selected");
                selectedCountry.style.fill = "";
                selectedCountry.style.stroke = "";
                selectedCountry.style.strokeWidth = "";
            }

            const countryElement = svg.querySelector(`[data-iso="${isoCode}"] path`);
            if (countryElement) {
                selectedCountry = countryElement;
                countryElement.classList.add("selected");
                countryElement.style.fill = "#3b82f6";
                countryElement.style.stroke = "#1e40af";
                countryElement.style.strokeWidth = "2";

                const bbox = countryElement.getBBox();
                const centerX = bbox.x + bbox.width / 2;
                const centerY = bbox.y + bbox.height / 2;

                viewBox.x = centerX - viewBox.width / 2;
                viewBox.y = centerY - viewBox.height / 2;
                svg.setAttribute("viewBox", `${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`);

                if (forceModal || mode === "modal") {
                    openCountryModal(isoCode);
                } else if (mode === "link") {
                    const href = countryElement.getAttribute("href");
                    if (href) {
                        window.location.href = href;
                    }
                }
            }
        }

        svg.addEventListener("click", (e) => {
            if (isPanning) return;

            const countryElement = e.target.closest(".country-path");
            if (countryElement) {
                e.preventDefault();
                const isoCode = countryElement.getAttribute("data-iso");
                if (mode === "modal") {
                    openCountryModal(isoCode);
                }
            }
        });

        setInitialViewBox();
    }
</script>
